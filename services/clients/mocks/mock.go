package mocks

import "context"
import "google.golang.org/grpc"
import (
	"github.com/stretchr/testify/mock"
	"github.com/makkalot/eskit/generated/grpc/go/crudstore"
	"github.com/makkalot/eskit/generated/grpc/go/consumerstore"
)

// ConsumerServiceClient is an autogenerated mock type for the ConsumerServiceClient type
type ConsumerServiceClient struct {
	mock.Mock
}

// GetLogConsume provides a mock function with given fields: ctx, in, opts
func (_m *ConsumerServiceClient) GetLogConsume(ctx context.Context, in *consumerstore.GetAppLogConsumeRequest, opts ...grpc.CallOption) (*consumerstore.GetAppLogConsumeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *consumerstore.GetAppLogConsumeResponse
	if rf, ok := ret.Get(0).(func(context.Context, *consumerstore.GetAppLogConsumeRequest, ...grpc.CallOption) *consumerstore.GetAppLogConsumeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*consumerstore.GetAppLogConsumeResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *consumerstore.GetAppLogConsumeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Healtz provides a mock function with given fields: ctx, in, opts
func (_m *ConsumerServiceClient) Healtz(ctx context.Context, in *consumerstore.HealthRequest, opts ...grpc.CallOption) (*consumerstore.HealthResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *consumerstore.HealthResponse
	if rf, ok := ret.Get(0).(func(context.Context, *consumerstore.HealthRequest, ...grpc.CallOption) *consumerstore.HealthResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*consumerstore.HealthResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *consumerstore.HealthRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, in, opts
func (_m *ConsumerServiceClient) List(ctx context.Context, in *consumerstore.ListConsumersRequest, opts ...grpc.CallOption) (*consumerstore.ListConsumersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *consumerstore.ListConsumersResponse
	if rf, ok := ret.Get(0).(func(context.Context, *consumerstore.ListConsumersRequest, ...grpc.CallOption) *consumerstore.ListConsumersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*consumerstore.ListConsumersResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *consumerstore.ListConsumersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogConsume provides a mock function with given fields: ctx, in, opts
func (_m *ConsumerServiceClient) LogConsume(ctx context.Context, in *consumerstore.AppLogConsumeRequest, opts ...grpc.CallOption) (*consumerstore.AppLogConsumeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *consumerstore.AppLogConsumeResponse
	if rf, ok := ret.Get(0).(func(context.Context, *consumerstore.AppLogConsumeRequest, ...grpc.CallOption) *consumerstore.AppLogConsumeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*consumerstore.AppLogConsumeResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *consumerstore.AppLogConsumeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CrudStoreServiceClient is an autogenerated mock type for the CrudStoreServiceClient type
type CrudStoreServiceClient struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) Create(ctx context.Context, in *crudstore.CreateRequest, opts ...grpc.CallOption) (*crudstore.CreateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.CreateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.CreateRequest, ...grpc.CallOption) *crudstore.CreateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.CreateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.CreateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) Delete(ctx context.Context, in *crudstore.DeleteRequest, opts ...grpc.CallOption) (*crudstore.DeleteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.DeleteResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.DeleteRequest, ...grpc.CallOption) *crudstore.DeleteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.DeleteResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.DeleteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) Get(ctx context.Context, in *crudstore.GetRequest, opts ...grpc.CallOption) (*crudstore.GetResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.GetResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.GetRequest, ...grpc.CallOption) *crudstore.GetResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.GetResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.GetRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetType provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) GetType(ctx context.Context, in *crudstore.GetTypeRequest, opts ...grpc.CallOption) (*crudstore.GetTypeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.GetTypeResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.GetTypeRequest, ...grpc.CallOption) *crudstore.GetTypeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.GetTypeResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.GetTypeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Healtz provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) Healtz(ctx context.Context, in *crudstore.HealthRequest, opts ...grpc.CallOption) (*crudstore.HealthResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.HealthResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.HealthRequest, ...grpc.CallOption) *crudstore.HealthResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.HealthResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.HealthRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) List(ctx context.Context, in *crudstore.ListRequest, opts ...grpc.CallOption) (*crudstore.ListResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.ListResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.ListRequest, ...grpc.CallOption) *crudstore.ListResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.ListResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.ListRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTypes provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) ListTypes(ctx context.Context, in *crudstore.ListTypesRequest, opts ...grpc.CallOption) (*crudstore.ListTypesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.ListTypesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.ListTypesRequest, ...grpc.CallOption) *crudstore.ListTypesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.ListTypesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.ListTypesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterType provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) RegisterType(ctx context.Context, in *crudstore.RegisterTypeRequest, opts ...grpc.CallOption) (*crudstore.RegisterTypeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.RegisterTypeResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.RegisterTypeRequest, ...grpc.CallOption) *crudstore.RegisterTypeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.RegisterTypeResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.RegisterTypeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) Update(ctx context.Context, in *crudstore.UpdateRequest, opts ...grpc.CallOption) (*crudstore.UpdateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.UpdateResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.UpdateRequest, ...grpc.CallOption) *crudstore.UpdateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.UpdateResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.UpdateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateType provides a mock function with given fields: ctx, in, opts
func (_m *CrudStoreServiceClient) UpdateType(ctx context.Context, in *crudstore.UpdateTypeRequest, opts ...grpc.CallOption) (*crudstore.UpdateTypeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *crudstore.UpdateTypeResponse
	if rf, ok := ret.Get(0).(func(context.Context, *crudstore.UpdateTypeRequest, ...grpc.CallOption) *crudstore.UpdateTypeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crudstore.UpdateTypeResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *crudstore.UpdateTypeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
